<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rogue Wave Survivor 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.jsの読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; touch-action: none; user-select: none; }
        /* Three.jsのキャンバスはJSで生成されます */
        
        .pixel-font { font-family: 'Courier New', Courier, monospace; font-weight: bold; }
        
        /* カスタムスクロールバー */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #333; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }

        /* UIオーバーレイのアニメーション */
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
    </style>
</head>
<body class="pixel-font">

    <!-- Three.js Container -->
    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <!-- UI: HUD (ゲーム中常時表示) -->
    <div id="hud" class="absolute top-0 left-0 w-full p-4 pointer-events-none hidden flex justify-between items-start text-shadow-md z-10">
        <div>
            <div class="text-xl text-yellow-400">WAVE: <span id="waveDisplay">1</span></div>
            <div class="text-white">HP: <span id="hpDisplay">100/100</span></div>
            <div class="text-yellow-200">GOLD: <span id="goldDisplay">0</span> G</div>
        </div>
        <div class="text-right">
            <div class="text-blue-300">POINTS: <span id="pointDisplay">0</span> PTS</div>
            <div class="text-xs text-gray-400 mt-1">WASD: 移動 | Click: 攻撃</div>
        </div>
    </div>

    <!-- UI: ウェーブクリア / ショップメニュー (右上に配置) -->
    <div id="waveMenu" class="absolute top-20 right-4 flex flex-col items-end hidden z-20 pointer-events-none">
        <div class="bg-gray-800/90 border-2 border-gray-600 p-4 rounded-lg shadow-2xl pointer-events-auto text-center interactive-ui max-w-sm fade-in">
            <h2 class="text-2xl text-yellow-400 mb-1">WAVE <span id="menuWaveNum"></span> CLEAR!</h2>
            <p class="mb-4 text-gray-300 text-sm">強化して次のウェーブへ</p>

            <div class="grid grid-cols-1 gap-2 mb-4">
                <button onclick="game.shopBuy('heal')" class="bg-green-700 hover:bg-green-600 text-white p-2 rounded flex justify-between items-center text-sm">
                    <span>HP回復 (50%)</span>
                    <span class="text-yellow-300 font-bold">50 G</span>
                </button>
                <button onclick="game.shopBuy('atk')" class="bg-red-700 hover:bg-red-600 text-white p-2 rounded flex justify-between items-center text-sm">
                    <span>攻撃力 UP (+1)</span>
                    <span class="text-yellow-300 font-bold">100 G</span>
                </button>
                <button onclick="game.shopBuy('speed')" class="bg-blue-700 hover:bg-blue-600 text-white p-2 rounded flex justify-between items-center text-sm">
                    <span>移動速度 UP</span>
                    <span class="text-yellow-300 font-bold">150 G</span>
                </button>
            </div>

            <div class="flex gap-2 justify-center mb-2">
                <button onclick="game.nextWave()" class="bg-yellow-600 hover:bg-yellow-500 text-white px-4 py-2 rounded font-bold text-base w-full">
                    次へ進む
                </button>
            </div>

            <div id="saveSection" class="border-t border-gray-600 pt-2 hidden">
                <p class="text-xs text-green-400 mb-1">★ セーブ可能 ★</p>
                <button onclick="game.saveAndQuit()" class="bg-purple-700 hover:bg-purple-600 text-white px-3 py-1 rounded w-full text-xs">
                    保存して終了
                </button>
            </div>
        </div>
    </div>

    <!-- UI: NPCメニュー -->
    <div id="npcMenu" class="absolute inset-0 bg-black/80 flex items-center justify-center hidden z-20">
        <div class="bg-slate-800 border-2 border-slate-500 p-6 rounded-lg max-w-md w-full shadow-2xl fade-in text-center interactive-ui">
            <h2 class="text-2xl text-green-400 mb-2">強化トレーナー</h2>
            <p class="text-sm text-gray-300 mb-4">獲得したポイントで基礎能力を底上げします。<br>(死んでもリセットされません)</p>
            <div class="text-right mb-4 text-blue-300 font-bold">所持ポイント: <span id="npcPoints">0</span></div>
            <div class="grid grid-cols-1 gap-2 mb-6">
                <button onclick="game.upgradeMeta('maxHp')" class="bg-gray-700 hover:bg-gray-600 p-3 rounded flex justify-between border border-gray-600">
                    <div class="text-left">
                        <div class="text-white">最大HP強化</div>
                        <div class="text-xs text-gray-400">現在: <span id="metaMaxHpVal">100</span></div>
                    </div>
                    <div class="text-blue-300 font-bold self-center">100 Pts</div>
                </button>
                <button onclick="game.upgradeMeta('baseAtk')" class="bg-gray-700 hover:bg-gray-600 p-3 rounded flex justify-between border border-gray-600">
                    <div class="text-left">
                        <div class="text-white">基礎攻撃力強化</div>
                        <div class="text-xs text-gray-400">現在: <span id="metaAtkVal">10</span></div>
                    </div>
                    <div class="text-blue-300 font-bold self-center">200 Pts</div>
                </button>
            </div>
            <button onclick="game.closeNpcMenu()" class="bg-gray-500 hover:bg-gray-400 text-white px-6 py-2 rounded w-full">閉じる</button>
        </div>
    </div>

    <!-- UI: ゲームオーバー -->
    <div id="gameOverMenu" class="absolute inset-0 bg-red-900/90 flex items-center justify-center hidden z-30">
        <div class="text-center fade-in">
            <h1 class="text-5xl text-white font-bold mb-4">YOU DIED</h1>
            <p class="text-xl text-yellow-200 mb-6">獲得ポイント: <span id="goPoints">0</span> PTS</p>
            <p class="text-lg text-white pulse font-bold">セーフゾーンへ帰還中...</p>
        </div>
    </div>

    <!-- UI: 通知 -->
    <div id="notification" class="absolute bottom-10 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded opacity-0 transition-opacity duration-300 pointer-events-none z-40">Message</div>

    <script>
        /**
         * ユーティリティ & 共通設定
         */
        const $ = (id) => document.getElementById(id);
        const random = (min, max) => Math.random() * (max - min) + min;
        const LOGIC_SCALE = 1.0; 

        // 2Dロジック用衝突判定
        const checkRectCollide = (r1, r2) => r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y;
        const checkCircleCollide = (c1, c2) => {
            const dx = c1.x - c2.x;
            const dy = c1.y - c2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < c1.r + c2.r;
        };

        const STORAGE_KEY_META = 'rogue_meta_v3d';
        const STORAGE_KEY_SAVE = 'rogue_save_v3d';

        // Three.js マテリアルキャッシュ
        const MAT = {
            player: new THREE.MeshStandardMaterial({ color: 0x3B82F6, roughness: 0.3 }),
            enemy: new THREE.MeshStandardMaterial({ color: 0xEF4444, roughness: 0.2 }),
            bullet: new THREE.MeshBasicMaterial({ color: 0xFFFFFF }),
            gold: new THREE.MeshStandardMaterial({ color: 0xFACC15, metalness: 0.8, roughness: 0.2 }),
            point: new THREE.MeshStandardMaterial({ color: 0x60A5FA, emissive: 0x224488 }),
            wall: new THREE.MeshStandardMaterial({ color: 0x475569 }),
            doorStart: new THREE.MeshStandardMaterial({ color: 0x854D0E, emissive: 0x422005 }),
            doorLoad: new THREE.MeshStandardMaterial({ color: 0x9333EA, emissive: 0x400560 }),
            doorFrame: new THREE.MeshStandardMaterial({ color: 0x333333 }),
            doorKnob: new THREE.MeshStandardMaterial({ color: 0xFFD700 }),
            npc: new THREE.MeshStandardMaterial({ color: 0x4ADE80 }),
            floorSafe: new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.8 }),
            floorBattle: new THREE.MeshStandardMaterial({ color: 0x3f6212, roughness: 0.9 }),
            eye: new THREE.MeshBasicMaterial({ color: 0xffffff }),
            skin: new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.5 }),
            hair: new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 }),
            pants: new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 }),
        };

        // 共通ジオメトリ
        const GEO = {
            bullet: new THREE.SphereGeometry(0.4, 8, 8),
            item: new THREE.IcosahedronGeometry(0.6, 0)
        };

        /**
         * 3Dモデル生成ヘルパー (リッチな人型モデル)
         */
        function createHumanoidGroup(mainMaterialTemplate, scale = 1.0) {
            const group = new THREE.Group();
            
            // マテリアルを全て複製して、個体ごとに独立させる (ダメージ発光用)
            const mainMaterial = mainMaterialTemplate.clone();
            const skinMat = MAT.skin.clone();
            const hairMat = MAT.hair.clone();
            const pantsMat = MAT.pants.clone();

            // --- 頭部 ---
            const headGroup = new THREE.Group();
            headGroup.position.y = 15;
            group.add(headGroup);

            // 顔
            const face = new THREE.Mesh(new THREE.BoxGeometry(8, 8, 8), skinMat);
            face.castShadow = true;
            headGroup.add(face);

            // 髪 (帽子のように)
            const hairGeo = new THREE.BoxGeometry(8.5, 2.5, 8.5);
            const hair = new THREE.Mesh(hairGeo, hairMat);
            hair.position.y = 3;
            hair.castShadow = true;
            headGroup.add(hair);
            
            // 目
            const eyeGeo = new THREE.BoxGeometry(2, 2, 1);
            const eyeL = new THREE.Mesh(eyeGeo, MAT.eye);
            eyeL.position.set(-2, 0, 4.1);
            headGroup.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, MAT.eye);
            eyeR.position.set(2, 0, 4.1);
            headGroup.add(eyeR);

            // --- 胴体 ---
            const body = new THREE.Mesh(new THREE.BoxGeometry(8, 10, 4), mainMaterial);
            body.position.y = 6;
            body.castShadow = true;
            group.add(body);

            // --- 腕 (関節あり風) ---
            const armGeo = new THREE.BoxGeometry(2.5, 9, 2.5);
            
            // 左腕
            const armLGroup = new THREE.Group();
            armLGroup.position.set(-5.5, 10, 0); // 肩の位置
            group.add(armLGroup);
            
            const armL = new THREE.Mesh(armGeo, mainMaterial);
            armL.position.y = -3;
            armL.castShadow = true;
            armLGroup.add(armL);
            
            const handL = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), skinMat);
            handL.position.y = -8.5; // 手先
            handL.castShadow = true;
            armLGroup.add(handL);
            
            // 右腕
            const armRGroup = new THREE.Group();
            armRGroup.position.set(5.5, 10, 0);
            group.add(armRGroup);
            
            const armR = new THREE.Mesh(armGeo, mainMaterial);
            armR.position.y = -3;
            armR.castShadow = true;
            armRGroup.add(armR);
            
            const handR = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), skinMat);
            handR.position.y = -8.5;
            handR.castShadow = true;
            armRGroup.add(handR);

            // --- 脚 (関節あり風) ---
            const legGeo = new THREE.BoxGeometry(3.2, 10, 3.2);
            
            // 左足
            const legLGroup = new THREE.Group();
            legLGroup.position.set(-2.2, 1, 0); // 股関節
            group.add(legLGroup);
            
            const legL = new THREE.Mesh(legGeo, pantsMat);
            legL.position.y = -5;
            legL.castShadow = true;
            legLGroup.add(legL);

            // 右足
            const legRGroup = new THREE.Group();
            legRGroup.position.set(2.2, 1, 0);
            group.add(legRGroup);
            
            const legR = new THREE.Mesh(legGeo, pantsMat);
            legR.position.y = -5;
            legR.castShadow = true;
            legRGroup.add(legR);

            // 名前をつけてアニメーションで参照できるようにする
            armLGroup.name = "ArmL";
            armRGroup.name = "ArmR";
            legLGroup.name = "LegL";
            legRGroup.name = "LegR";

            group.scale.set(scale, scale, scale);
            return group;
        }

        function createDoorGroup(material) {
            const group = new THREE.Group();
            const w = 40, h = 50, d = 4;
            
            // Frame
            const sideGeo = new THREE.BoxGeometry(4, h, 6);
            const topGeo = new THREE.BoxGeometry(w + 8, 4, 6);
            
            const leftPost = new THREE.Mesh(sideGeo, MAT.doorFrame);
            leftPost.position.set(-(w/2 + 2), h/2, 0);
            leftPost.castShadow = true;
            group.add(leftPost);

            const rightPost = new THREE.Mesh(sideGeo, MAT.doorFrame);
            rightPost.position.set(w/2 + 2, h/2, 0);
            rightPost.castShadow = true;
            group.add(rightPost);

            const topPost = new THREE.Mesh(topGeo, MAT.doorFrame);
            topPost.position.set(0, h + 2, 0);
            topPost.castShadow = true;
            group.add(topPost);

            // Panel
            const panel = new THREE.Mesh(new THREE.BoxGeometry(w, h, 2), material);
            panel.position.set(0, h/2, 0);
            group.add(panel);

            // Knob
            const knob = new THREE.Mesh(new THREE.SphereGeometry(2), MAT.doorKnob);
            knob.position.set(15, h/2, 2.5);
            group.add(knob);

            return group;
        }

        /**
         * ゲームクラス
         */
        class Game {
            constructor() {
                this.initThree();
                
                this.state = 'SAFE_ZONE';
                this.wave = 1;
                this.difficultyMultiplier = 1;
                
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                this.raycaster = new THREE.Raycaster();
                this.setupInput();

                // エンティティ (論理データ + 3Dメッシュ)
                this.player = null;
                this.enemies = [];
                this.bullets = [];
                this.items = [];
                this.walls = []; // ロジック壁
                this.interactables = [];
                this.interactableMeshes = []; // 3D表示用
                
                this.metaData = this.loadMetaData();
                this.runData = { gold: 0, pointsGainedRun: 0 };

                this.initSafeZone();
                this.animate();
            }

            initThree() {
                const container = $('canvas-container');
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050505);
                this.scene.fog = new THREE.FogExp2(0x050505, 0.0015);

                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
                this.camera.position.set(0, 400, 300);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                container.appendChild(this.renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(ambientLight);

                this.dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
                this.dirLight.position.set(100, 200, 100);
                this.dirLight.castShadow = true;
                // 影の範囲を広げて、途切れ（枠線に見える現象）を防止
                this.dirLight.shadow.camera.top = 2000;
                this.dirLight.shadow.camera.bottom = -2000;
                this.dirLight.shadow.camera.left = -2000;
                this.dirLight.shadow.camera.right = 2000;
                this.dirLight.shadow.mapSize.width = 2048;
                this.dirLight.shadow.mapSize.height = 2048;
                this.scene.add(this.dirLight);

                this.playerLight = new THREE.PointLight(0xffffff, 0.5, 500);
                this.scene.add(this.playerLight);

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                this.planeGeometry = new THREE.PlaneGeometry(10000, 10000);
                this.plane = new THREE.Mesh(this.planeGeometry, new THREE.MeshBasicMaterial({ visible: false }));
                this.plane.rotation.x = -Math.PI / 2;
                this.scene.add(this.plane);
            }

            setupInput() {
                window.addEventListener('keydown', e => this.keys[e.code] = true);
                window.addEventListener('keyup', e => this.keys[e.code] = false);
                
                window.addEventListener('mousemove', e => {
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    this.raycaster.setFromCamera({ x, y }, this.camera);
                    const intersects = this.raycaster.intersectObject(this.plane);
                    if (intersects.length > 0) {
                        this.mouse.x = intersects[0].point.x;
                        this.mouse.y = intersects[0].point.z; 
                    }
                });

                window.addEventListener('mousedown', (e) => {
                    // UI要素をクリックしたときは攻撃しない
                    if (e.target.closest('button') || e.target.closest('.interactive-ui')) return;

                    this.mouse.down = true;
                    if (this.state === 'PLAYING' && this.player) this.player.shoot();
                });
                window.addEventListener('mouseup', () => this.mouse.down = false);
            }

            // --- 状態管理 & ロード/セーブ ---

            loadMetaData() {
                const data = localStorage.getItem(STORAGE_KEY_META);
                return data ? JSON.parse(data) : { points: 0, maxHpLevel: 0, atkLevel: 0 };
            }

            saveMetaData() {
                localStorage.setItem(STORAGE_KEY_META, JSON.stringify(this.metaData));
            }

            hasSaveData() { return localStorage.getItem(STORAGE_KEY_SAVE) !== null; }

            loadSaveGame() {
                const save = JSON.parse(localStorage.getItem(STORAGE_KEY_SAVE));
                if (!save) return;
                this.wave = save.wave;
                this.runData.gold = save.gold;
                this.runData.pointsGainedRun = save.pointsGainedRun;
                this.difficultyMultiplier = 1 + (this.wave * 0.1);
                
                this.tempLoadStats = save.player;
                this.startBattlePhase(true);
            }

            // --- シーン構築 ---

            clearEntities() {
                if (this.player && this.player.mesh) this.scene.remove(this.player.mesh);
                this.enemies.forEach(e => this.scene.remove(e.mesh));
                this.bullets.forEach(b => this.scene.remove(b.mesh));
                this.items.forEach(i => this.scene.remove(i.mesh));
                this.interactableMeshes.forEach(m => this.scene.remove(m));
                if (this.currentFloorMesh) this.scene.remove(this.currentFloorMesh);

                this.enemies = [];
                this.bullets = [];
                this.items = [];
                this.interactables = [];
                this.interactableMeshes = [];
                this.walls = [];
            }

            initSafeZone() {
                this.state = 'SAFE_ZONE';
                this.clearEntities();

                const roomW = 400, roomH = 300;

                // 1. 床
                const floorGeo = new THREE.BoxGeometry(roomW, 10, roomH);
                this.currentFloorMesh = new THREE.Mesh(floorGeo, MAT.floorSafe);
                this.currentFloorMesh.position.set(0, -5, 0);
                this.currentFloorMesh.receiveShadow = true;
                this.scene.add(this.currentFloorMesh);

                // 2. プレイヤー
                const baseMaxHp = 100 + (this.metaData.maxHpLevel * 10);
                const baseAtk = 10 + (this.metaData.atkLevel * 2);
                this.player = new Player(0, 0, baseMaxHp, baseAtk);
                this.scene.add(this.player.mesh);

                // 3. 壁 (ロジック)
                this.walls.push({x: -2000, y: -2000, w: 4000, h: 2000 - roomH/2}); // 上
                this.walls.push({x: -2000, y: roomH/2, w: 4000, h: 2000}); // 下
                this.walls.push({x: -2000, y: -roomH/2, w: 2000 - roomW/2, h: roomH}); // 左
                this.walls.push({x: roomW/2, y: -roomH/2, w: 2000, h: roomH}); // 右

                // 4. 壁 (3Dビジュアル)
                const wallThick = 10;
                const wallH = 40;
                const createWall = (x, z, w, d) => {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(w, wallH, d), MAT.wall);
                    m.position.set(x, wallH/2, z);
                    m.castShadow = true;
                    this.scene.add(m);
                    this.interactableMeshes.push(m);
                };
                createWall(0, -roomH/2 - wallThick/2, roomW + wallThick*2, wallThick);
                createWall(0, roomH/2 + wallThick/2, roomW + wallThick*2, wallThick);
                createWall(-roomW/2 - wallThick/2, 0, wallThick, roomH);
                createWall(roomW/2 + wallThick/2, 0, wallThick, roomH);

                // 5. NPC (人型)
                this.interactables.push({ type: 'npc', x: -100, y: -60, r: 20, action: () => this.openNpcMenu() });
                const npcMesh = createHumanoidGroup(MAT.npc, 1.2); // 少し大きめ
                npcMesh.position.set(-100, 12, -60); // Y位置調整: scale 1.2 なので 10*1.2 = 12
                npcMesh.lookAt(0, 12, 0); // 中央を向く
                this.scene.add(npcMesh);
                this.interactableMeshes.push(npcMesh);

                // NPCカーペット
                const carpet = new THREE.Mesh(new THREE.PlaneGeometry(60, 60), new THREE.MeshStandardMaterial({color: 0x7f1d1d}));
                carpet.rotation.x = -Math.PI/2;
                carpet.position.set(-100, 0.2, -60);
                this.scene.add(carpet);
                this.interactableMeshes.push(carpet);

                // 6. ドア (New Game)
                this.interactables.push({ type: 'door', x: -25, y: -140, w: 50, h: 20, action: () => this.startNewGame() });
                const doorMesh = createDoorGroup(MAT.doorStart);
                doorMesh.position.set(0, 0, -148);
                this.scene.add(doorMesh);
                this.interactableMeshes.push(doorMesh);
                
                // 7. ドア (Load Game)
                if (this.hasSaveData()) {
                    this.interactables.push({ type: 'door', x: 100, y: -140, w: 50, h: 20, action: () => this.loadSaveGame() });
                    const loadMesh = createDoorGroup(MAT.doorLoad);
                    loadMesh.position.set(125, 0, -148);
                    this.scene.add(loadMesh);
                    this.interactableMeshes.push(loadMesh);
                }

                // UI Reset
                $('hud').classList.add('hidden');
                $('waveMenu').classList.add('hidden');
                $('npcMenu').classList.add('hidden');
                $('gameOverMenu').classList.add('hidden');
            }

            startNewGame() {
                localStorage.removeItem(STORAGE_KEY_SAVE);
                this.wave = 1;
                this.difficultyMultiplier = 1;
                this.runData = { gold: 0, pointsGainedRun: 0 };
                this.tempLoadStats = null;
                this.startBattlePhase();
            }

            startBattlePhase(isLoad = false) {
                this.state = 'PLAYING';
                this.clearEntities();

                // バトルフィールド
                const fieldSize = 1500;
                this.currentFloorMesh = new THREE.Mesh(new THREE.PlaneGeometry(fieldSize, fieldSize), MAT.floorBattle);
                this.currentFloorMesh.rotation.x = -Math.PI / 2;
                this.currentFloorMesh.receiveShadow = true;
                this.scene.add(this.currentFloorMesh);

                // グリッドヘルパーを削除（見た目をスッキリさせるため）
                // const grid = new THREE.GridHelper(fieldSize, 30, 0x2f4f4f, 0x2f4f4f);
                // grid.position.y = 0.1;
                // this.currentFloorMesh.add(grid);

                // ステージ境界の壁 (不可視) を追加
                const w = 100;
                const limit = 750; // fieldSize / 2
                this.walls.push({x: -limit - w, y: -limit - w, w: limit*2 + w*2, h: w}); // 上
                this.walls.push({x: -2000, y: -2000, w: 4000, h: 2000 - limit}); // 上の黒い部分カバー
                this.walls.push({x: -2000, y: limit, w: 4000, h: 2000}); // 下
                this.walls.push({x: -2000, y: -limit, w: 2000 - limit, h: limit*2}); // 左
                this.walls.push({x: limit, y: -limit, w: 2000, h: limit*2}); // 右

                // プレイヤー再配置
                const baseMaxHp = 100 + (this.metaData.maxHpLevel * 10);
                const baseAtk = 10 + (this.metaData.atkLevel * 2);
                this.player = new Player(0, 0, baseMaxHp, baseAtk);
                
                if (this.tempLoadStats) {
                    this.player.hp = this.tempLoadStats.hp;
                    this.player.atk = this.tempLoadStats.atk;
                    this.player.maxHp = this.tempLoadStats.maxHp;
                    this.player.speed = this.tempLoadStats.speed;
                    this.tempLoadStats = null;
                }

                this.scene.add(this.player.mesh);

                $('hud').classList.remove('hidden');
                this.updateHud();

                if (!isLoad) this.spawnWave();
                else setTimeout(() => this.spawnWave(), 1000);
            }

            spawnWave() {
                const enemyCount = 5 + Math.floor(this.wave * 1.5);
                const speedMulti = 1 + (this.wave * 0.05);
                const hpMulti = 1 + (this.wave * 0.1);

                for (let i = 0; i < enemyCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 400 + Math.random() * 200;
                    const ex = this.player.x + Math.cos(angle) * dist;
                    const ey = this.player.y + Math.sin(angle) * dist;
                    
                    const enemy = new Enemy(ex, ey, hpMulti, speedMulti);
                    this.enemies.push(enemy);
                    this.scene.add(enemy.mesh);
                }
                this.showNotification(`WAVE ${this.wave} START!`);
                this.updateHud();
            }

            // --- ゲームループ & ロジック ---

            animate() {
                requestAnimationFrame(() => this.animate());
                this.update();
                this.render();
            }

            update() {
                if (this.state !== 'PLAYING' && this.state !== 'SAFE_ZONE') return;

                // プレイヤー更新
                if (this.player) {
                    this.player.update(this.keys, this.mouse, this.walls);
                    
                    const targetX = this.player.x;
                    const targetZ = this.player.y + 300; 
                    this.camera.position.x += (targetX - this.camera.position.x) * 0.1;
                    this.camera.position.z += (targetZ - this.camera.position.z) * 0.1;
                    // カメラの回転(lookAt)を削除し、固定アングルでの追従に変更
                    // this.camera.lookAt(this.player.x, 0, this.player.y);

                    this.playerLight.position.set(this.player.x, 50, this.player.y);
                }

                // 弾更新
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const b = this.bullets[i];
                    b.update();
                    if (Math.abs(b.x - this.player.x) > 1200 || Math.abs(b.y - this.player.y) > 1200) {
                        this.scene.remove(b.mesh);
                        this.bullets.splice(i, 1);
                        continue;
                    }
                    if (this.state === 'PLAYING') {
                        for (let j = this.enemies.length - 1; j >= 0; j--) {
                            const e = this.enemies[j];
                            if (checkCircleCollide(b, e)) {
                                e.takeDamage(this.player.atk);
                                this.scene.remove(b.mesh);
                                this.bullets.splice(i, 1);
                                if (e.hp <= 0) this.killEnemy(e, j);
                                break;
                            }
                        }
                    }
                }

                // 敵更新
                if (this.state === 'PLAYING') {
                    for (let i = 0; i < this.enemies.length; i++) {
                        const e = this.enemies[i];
                        e.update(this.player);
                        if (checkCircleCollide(e, this.player)) {
                            this.player.takeDamage(10 * this.difficultyMultiplier);
                            e.recoil(this.player);
                            this.updateHud();
                            if (this.player.hp <= 0) this.handleGameOver();
                        }
                    }
                }

                // アイテム収集
                for (let i = this.items.length - 1; i >= 0; i--) {
                    const item = this.items[i];
                    item.update();
                    const dist = Math.hypot(this.player.x - item.x, this.player.y - item.y);
                    if (dist < 150) { 
                        item.x += (this.player.x - item.x) * 0.1;
                        item.y += (this.player.y - item.y) * 0.1;
                    }
                    if (dist < 30) {
                        if (item.type === 'gold') {
                            this.runData.gold += item.value;
                            this.showNotification(`+${item.value} G`);
                        } else {
                            this.runData.pointsGainedRun += item.value;
                        }
                        this.scene.remove(item.mesh);
                        this.items.splice(i, 1);
                        this.updateHud();
                    }
                }

                // インタラクション
                if (this.state === 'SAFE_ZONE') {
                    for (let obj of this.interactables) {
                        if (obj.type === 'door') {
                            if (checkRectCollide({x:this.player.x-15, y:this.player.y-15, w:30, h:30}, obj)) obj.action();
                        } else {
                            const dist = Math.hypot(this.player.x - obj.x, this.player.y - obj.y);
                            if (dist < 40) obj.action();
                        }
                    }
                }
            }

            render() {
                this.renderer.render(this.scene, this.camera);
            }

            // --- ゲームプレイイベント ---

            killEnemy(enemy, index) {
                this.scene.remove(enemy.mesh);
                this.enemies.splice(index, 1);
                
                // お金はドロップする
                const gold = new Item(enemy.x, enemy.y, 'gold', Math.floor(random(10, 30)));
                this.items.push(gold);
                this.scene.add(gold.mesh);

                // ポイントは自動取得（ドロップしない）
                const pts = Math.floor(random(5, 15));
                this.runData.pointsGainedRun += pts;
                this.updateHud(); // HUDを即座に更新

                if (this.enemies.length === 0) {
                    setTimeout(() => {
                        // this.state = 'MENU'; // 削除: MENUステートにせずPLAYINGを維持して動けるようにする
                        this.openWaveMenu();
                    }, 1000);
                }
            }

            openWaveMenu() {
                $('waveMenu').classList.remove('hidden');
                $('menuWaveNum').innerText = this.wave;
                $('saveSection').classList.toggle('hidden', this.wave % 10 !== 0);
            }

            nextWave() {
                $('waveMenu').classList.add('hidden');
                this.wave++;
                this.state = 'PLAYING';
                this.spawnWave();
            }

            handleGameOver() {
                this.state = 'GAME_OVER';
                localStorage.removeItem(STORAGE_KEY_SAVE);
                this.metaData.points += this.runData.pointsGainedRun;
                this.saveMetaData();
                $('goPoints').innerText = this.runData.pointsGainedRun;
                $('gameOverMenu').classList.remove('hidden');
                setTimeout(() => this.initSafeZone(), 3000);
            }

            saveAndQuit() {
                const saveData = {
                    wave: this.wave, gold: this.runData.gold, pointsGainedRun: this.runData.pointsGainedRun,
                    player: { maxHp: this.player.maxHp, hp: this.player.hp, atk: this.player.atk, speed: this.player.speed }
                };
                localStorage.setItem(STORAGE_KEY_SAVE, JSON.stringify(saveData));
                this.initSafeZone();
                this.showNotification("保存しました");
            }

            // --- UI関連 ---
            
            updateHud() {
                $('waveDisplay').innerText = this.wave;
                $('hpDisplay').innerText = `${Math.ceil(this.player.hp)}/${this.player.maxHp}`;
                $('goldDisplay').innerText = this.runData.gold;
                $('pointDisplay').innerText = this.runData.pointsGainedRun;
                $('hpDisplay').style.color = (this.player.hp / this.player.maxHp) < 0.3 ? '#ef4444' : 'white';
            }

            showNotification(msg) {
                const el = $('notification');
                el.innerText = msg;
                el.style.opacity = 1;
                el.style.transform = 'translate(-50%, 0)';
                setTimeout(() => {
                    el.style.opacity = 0;
                    el.style.transform = 'translate(-50%, 10px)';
                }, 2000);
            }

            shopBuy(type) {
                const costs = { heal: 50, atk: 100, speed: 150 };
                if (this.runData.gold >= costs[type]) {
                    let bought = false;
                    if (type === 'heal' && this.player.hp < this.player.maxHp) {
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.maxHp * 0.5); bought = true;
                    } else if (type === 'atk') { this.player.atk++; bought = true; }
                    else if (type === 'speed') { this.player.speed += 0.2; bought = true; }

                    if (bought) {
                        this.runData.gold -= costs[type];
                        this.updateHud();
                        this.showNotification("購入！");
                    }
                } else this.showNotification("お金が足りません");
            }

            openNpcMenu() { this.state = 'MENU'; $('npcMenu').classList.remove('hidden'); this.updateNpcMenu(); }
            closeNpcMenu() { $('npcMenu').classList.add('hidden'); this.state = 'SAFE_ZONE'; this.player.y += 40; }
            updateNpcMenu() {
                $('npcPoints').innerText = this.metaData.points;
                $('metaMaxHpVal').innerText = 100 + (this.metaData.maxHpLevel * 10);
                $('metaAtkVal').innerText = 10 + (this.metaData.atkLevel * 2);
            }
            upgradeMeta(type) {
                const costs = { maxHp: 100, baseAtk: 200 };
                if (this.metaData.points >= costs[type]) {
                    this.metaData.points -= costs[type];
                    if (type === 'maxHp') { this.metaData.maxHpLevel++; }
                    if (type === 'baseAtk') { this.metaData.atkLevel++; }
                    this.saveMetaData(); this.updateNpcMenu();
                    this.player.maxHp = 100 + (this.metaData.maxHpLevel * 10);
                    this.player.atk = 10 + (this.metaData.atkLevel * 2);
                    this.player.hp = this.player.maxHp;
                } else this.showNotification("ポイント不足");
            }
        }

        /**
         * エンティティクラス (Logic + Mesh Sync)
         */
        class Player {
            constructor(x, y, maxHp, atk) {
                this.x = x; this.y = y; this.r = 15;
                this.maxHp = maxHp; this.hp = maxHp; this.atk = atk;
                this.speed = 2.5;
                this.lastShot = 0; this.fireRate = 300;

                // 3D Mesh
                this.mesh = createHumanoidGroup(MAT.player);
                this.mesh.position.set(x, 10, y); // Y=10 で足元が地面に合う
                this.parts = {
                    armL: this.mesh.getObjectByName("ArmL"),
                    armR: this.mesh.getObjectByName("ArmR"),
                    legL: this.mesh.getObjectByName("LegL"),
                    legR: this.mesh.getObjectByName("LegR")
                };
            }

            update(keys, mouse, walls) {
                let dx = 0, dy = 0;
                if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
                if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
                if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
                if (keys['KeyD'] || keys['ArrowRight']) dx = 1;

                const isMoving = (dx !== 0 || dy !== 0);

                if (isMoving) {
                    const len = Math.sqrt(dx*dx + dy*dy);
                    dx /= len; dy /= len;
                    const nextX = this.x + dx * this.speed;
                    const nextY = this.y + dy * this.speed;

                    let colX = false, colY = false;
                    const pRectX = {x: nextX-this.r, y: this.y-this.r, w: this.r*2, h: this.r*2};
                    const pRectY = {x: this.x-this.r, y: nextY-this.r, w: this.r*2, h: this.r*2};
                    
                    for (let w of walls) {
                        if (checkRectCollide(pRectX, w)) colX = true;
                        if (checkRectCollide(pRectY, w)) colY = true;
                    }
                    if (!colX) this.x = nextX;
                    if (!colY) this.y = nextY;

                    // 歩行アニメーション
                    const time = Date.now() * 0.015;
                    if(this.parts.armL) this.parts.armL.rotation.x = Math.sin(time) * 0.5;
                    if(this.parts.armR) this.parts.armR.rotation.x = -Math.sin(time) * 0.5;
                    if(this.parts.legL) this.parts.legL.rotation.x = -Math.sin(time) * 0.5;
                    if(this.parts.legR) this.parts.legR.rotation.x = Math.sin(time) * 0.5;
                } else {
                    // 停止
                    if(this.parts.armL) this.parts.armL.rotation.x = 0;
                    if(this.parts.armR) this.parts.armR.rotation.x = 0;
                    if(this.parts.legL) this.parts.legL.rotation.x = 0;
                    if(this.parts.legR) this.parts.legR.rotation.x = 0;
                }

                // 3D位置同期
                this.mesh.position.x = this.x;
                this.mesh.position.z = this.y;

                // マウスの方向を向く
                this.mesh.lookAt(mouse.x, 10, mouse.y);
            }

            shoot() {
                const now = Date.now();
                if (now - this.lastShot > this.fireRate) {
                    const angle = Math.atan2(game.mouse.y - this.y, game.mouse.x - this.x);
                    const b = new Bullet(this.x, this.y, angle);
                    game.bullets.push(b);
                    game.scene.add(b.mesh);
                    this.lastShot = now;
                }
            }

            takeDamage(amt) {
                this.hp -= amt;
                // ヒットエフェクト
                this.mesh.traverse(child => {
                    // MeshStandardMaterialのみ対象にする（emissiveを持つため）
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        // 連続被弾しても色が戻るように、現在の色を保存せず赤くし、必ず黒(0x000000)に戻す
                        child.material.emissive.setHex(0xff0000);
                        setTimeout(() => {
                            // オブジェクトがまだ存在しているか確認
                            if (child && child.material && child.material.emissive) {
                                child.material.emissive.setHex(0x000000);
                            }
                        }, 100);
                    }
                });
            }
        }

        class Enemy {
            constructor(x, y, hpMulti, speedMulti) {
                this.x = x; this.y = y; this.r = 15;
                this.maxHp = 30 * hpMulti; this.hp = this.maxHp;
                this.speed = (0.8 + Math.random() * 0.7) * speedMulti;

                this.mesh = createHumanoidGroup(MAT.enemy, 1.1); // 少し大きめ
                this.mesh.position.set(x, 11, y); // Y=11 (10*1.1) で地面に合わせる
                this.parts = {
                    armL: this.mesh.getObjectByName("ArmL"),
                    armR: this.mesh.getObjectByName("ArmR"),
                    legL: this.mesh.getObjectByName("LegL"),
                    legR: this.mesh.getObjectByName("LegR")
                };
            }

            update(player) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                    
                    // 歩行アニメーション
                    const time = Date.now() * 0.015;
                    if(this.parts.armL) this.parts.armL.rotation.x = Math.sin(time) * 0.5;
                    if(this.parts.armR) this.parts.armR.rotation.x = -Math.sin(time) * 0.5;
                    if(this.parts.legL) this.parts.legL.rotation.x = -Math.sin(time) * 0.5;
                    if(this.parts.legR) this.parts.legR.rotation.x = Math.sin(time) * 0.5;
                }
                
                this.mesh.position.x = this.x;
                this.mesh.position.z = this.y;
                // プレイヤーを向く
                this.mesh.lookAt(player.x, 11, player.y);
            }

            takeDamage(amt) {
                this.hp -= amt;
                // ダメージ演出
                this.mesh.scale.set(1.3, 1.3, 1.3);
                setTimeout(() => this.mesh.scale.set(1.1, 1.1, 1.1), 50);
                
                this.mesh.traverse(child => {
                    // MeshStandardMaterialのみ対象にする
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        // 連続被弾対策：必ず黒に戻す
                        child.material.emissive.setHex(0xffaaaa);
                        setTimeout(() => {
                            if (child && child.material && child.material.emissive) {
                                child.material.emissive.setHex(0x000000);
                            }
                        }, 100);
                    }
                });
            }

            recoil(player) {
                const angle = Math.atan2(this.y - player.y, this.x - player.x);
                this.x += Math.cos(angle) * 30;
                this.y += Math.sin(angle) * 30;
                this.mesh.position.x = this.x;
                this.mesh.position.z = this.y;
            }
        }

        class Bullet {
            constructor(x, y, angle) {
                this.x = x; this.y = y; this.r = 5;
                this.speed = 12;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;

                this.mesh = new THREE.Mesh(GEO.bullet, MAT.bullet);
                this.mesh.scale.set(10, 10, 10);
                this.mesh.position.set(x, 15, y);
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.mesh.position.x = this.x;
                this.mesh.position.z = this.y;
            }
        }

        class Item {
            constructor(x, y, type, value) {
                this.x = x; this.y = y; this.r = 10;
                this.type = type; this.value = value;
                
                this.mesh = new THREE.Mesh(GEO.item, type === 'gold' ? MAT.gold : MAT.point);
                this.mesh.scale.set(12, 12, 12);
                this.mesh.position.set(x, 10, y);
            }
            update() {
                this.mesh.position.x = this.x;
                this.mesh.position.z = this.y;
                this.mesh.rotation.y += 0.05;
                this.mesh.rotation.z += 0.05;
            }
        }

        const game = new Game();
    </script>
</body>
</html>